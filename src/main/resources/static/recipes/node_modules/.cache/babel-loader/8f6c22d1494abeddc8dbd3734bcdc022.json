{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"react\"));else if (typeof define === 'function' && define.amd) define([\"react\"], factory);else if (typeof exports === 'object') exports[\"Style\"] = factory(require(\"react\"));else root[\"Style\"] = factory(root[\"React\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_2__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"\";\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _reactLibAdler = __webpack_require__(1);\n\n      var _reactLibAdler2 = _interopRequireDefault(_reactLibAdler);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n      /**\n       * Copyright 2016-present, Joshua Robinson\n       * All rights reserved.\n       *\n       * This source code is licensed under the MIT license.\n       *\n       */\n\n\n      var __DEV__ = \"production\" !== 'production';\n\n      var Style = function (_Component) {\n        _inherits(Style, _Component);\n\n        function Style(props) {\n          _classCallCheck(this, Style);\n\n          var _this = _possibleConstructorReturn(this, (Style.__proto__ || Object.getPrototypeOf(Style)).call(this, props));\n\n          _this.getStyleString = function () {\n            if (_this.props.children instanceof Array) {\n              var styleString = _this.props.children.filter(function (child) {\n                return !(0, _react.isValidElement)(child) && typeof child === 'string';\n              });\n\n              if (styleString.length > 1) {\n                throw new Error('Multiple style objects as direct descedents of a ' + 'Style component are not supported (' + styleString.length + ' style objects detected): \\n\\n' + styleString[0]);\n              }\n\n              return styleString[0];\n            } else if (typeof _this.props.children === 'string' && !(0, _react.isValidElement)(_this.props.children)) {\n              return _this.props.children;\n            } else {\n              return null;\n            }\n          };\n\n          _this.getRootElement = function () {\n            if (_this.props.children instanceof Array) {\n              var rootElement = _this.props.children.filter(function (child) {\n                return (0, _react.isValidElement)(child);\n              });\n\n              if (__DEV__) {\n                if (rootElement.length > 1) {\n                  console.log(rootElement);\n                  throw new Error('Adjacent JSX elements must be wrapped in an enclosing tag (' + rootElement.length + ' root elements detected).');\n                }\n\n                if (typeof rootElement[0] !== 'undefined' && _this.isVoidElement(rootElement[0].type)) {\n                  throw new Error('Self-closing void elements like ' + rootElement.type + ' must be wrapped ' + 'in an enclosing tag. Reactive Style must be able to nest a style element ' + 'inside of the root element and void element content models never allow' + 'it to have contents under any circumstances.');\n                }\n              }\n\n              return rootElement[0];\n            } else if ((0, _react.isValidElement)(_this.props.children)) {\n              return _this.props.children;\n            } else {\n              return null;\n            }\n          };\n\n          _this.getRootSelectors = function (rootElement) {\n            var rootSelectors = []; // Handle id\n\n            if (rootElement.props.id) {\n              rootSelectors.push('#' + rootElement.props.id);\n            } // Handle classes\n\n\n            if (rootElement.props.className) {\n              rootElement.props.className.trim().split(/\\s+/g).forEach(function (className) {\n                return rootSelectors.push(className);\n              });\n            } // Handle no root selector by using type\n\n\n            if (!rootSelectors.length && typeof rootElement.type !== 'function') {\n              rootSelectors.push(rootElement.type);\n            }\n\n            return rootSelectors;\n          };\n\n          _this.processCSSText = function (styleString, scopeClassName, rootSelectors) {\n            // TODO: Look into using memoizeStringOnly from fbjs/lib for escaped strings;\n            // can avoid much of the computation as long as scoped doesn't come into play\n            // which would be unique\n            // TODO: If dev lint and provide feedback\n            // if linting fails we need to error out because\n            // the style string will not be parsed correctly\n            return styleString.replace(/\\s*\\/\\/(?![^(]*\\)).*|\\s*\\/\\*.*\\*\\//g, '') // Strip javascript style comments\n            .replace(/\\s\\s+/g, ' ') // Convert multiple to single whitespace\n            .split('}') // Start breaking down statements\n            .map(function (fragment) {\n              var isDeclarationBodyPattern = /.*:.*;/g;\n              var isLastItemDeclarationBodyPattern = /.*:.*(;|$|\\s+)/g;\n              var isAtRulePattern = /\\s*@/g;\n              var isKeyframeOffsetPattern = /\\s*(([0-9][0-9]?|100)\\s*%)|\\s*(to|from)\\s*$/g; // Split fragment into selector and declarationBody; escape declaration body\n\n              return fragment.split('{').map(function (statement, i, arr) {\n                // Avoid processing whitespace\n                if (!statement.trim().length) {\n                  return '';\n                }\n\n                var isDeclarationBodyItemWithOptionalSemicolon = // Only for the last property-value in a\n                // CSS declaration body is a semicolon optional\n                arr.length - 1 === i && statement.match(isLastItemDeclarationBodyPattern); // Skip escaping selectors statements since that would break them;\n                // note in docs that selector statements are not escaped and should\n                // not be generated from user provided strings\n\n                if (statement.match(isDeclarationBodyPattern) || isDeclarationBodyItemWithOptionalSemicolon) {\n                  return _this.escapeTextContentForBrowser(statement);\n                } else {\n                  // Statement is a selector\n                  var selector = statement;\n\n                  if (scopeClassName && !/:target/gi.test(selector)) {\n                    // Prefix the scope to the selector if it is not an at-rule\n                    if (!selector.match(isAtRulePattern) && !selector.match(isKeyframeOffsetPattern)) {\n                      return _this.scopeSelector(scopeClassName, selector, rootSelectors);\n                    } else {\n                      // Is at-rule or keyframe offset and should not be scoped\n                      return selector;\n                    }\n                  } else {\n                    // No scope; do nothing to the selector\n                    return selector;\n                  }\n                } // Pretty print in dev\n\n              }).join('{\\n');\n            }).join('}\\n');\n          };\n\n          _this.escaper = function (match) {\n            var ESCAPE_LOOKUP = {\n              '>': '&gt;',\n              '<': '&lt;'\n            };\n            return ESCAPE_LOOKUP[match];\n          };\n\n          _this.escapeTextContentForBrowser = function (text) {\n            var ESCAPE_REGEX = /[><]/g;\n            return ('' + text).replace(ESCAPE_REGEX, _this.escaper);\n          };\n\n          _this.scopeSelector = function (scopeClassName, selector, rootSelectors) {\n            var scopedSelector = []; // Matches comma-delimiters in multi-selectors (\".fooClass, .barClass {...}\" => \",\" );\n            // ignores commas-delimiters inside of brackets and parenthesis ([attr=value], :not()..)\n\n            var groupOfSelectorsPattern = /,(?![^(|[]*\\)|\\])/g;\n            var selectors = selector.split(groupOfSelectorsPattern);\n\n            for (var i = 0; i < selectors.length; i++) {\n              var containsSelector = void 0; // [data-scoped=\"54321\"] .someClass\n\n              var unionSelector = void 0; // [data-scoped=\"54321\"].someClass (account for root)\n\n              if (rootSelectors.length && rootSelectors.some(function (rootSelector) {\n                return selector.match(rootSelector);\n              })) {\n                unionSelector = selectors[i]; // Can't just add them together because of selector combinator complexity\n                // like '.rootClassName.someClass.otherClass > *' or :not('.rootClassName'),\n                // replace must be used\n                // Escape valid CSS special characters that are also RegExp special characters\n\n                var escapedRootSelectors = rootSelectors.map(function (rootSelector) {\n                  return rootSelector.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n                });\n                unionSelector = unionSelector.replace(new RegExp('(' + // Start capture group\n                escapedRootSelectors.join('|') + // Match any one root selector\n                ')' // End capture group\n                ), '$1' + scopeClassName // Replace any one root selector match with a union\n                ); // of the root selector and scoping class (e.g., .rootSelector._scoped-1). Order matters here because of type-class union support like div._scoped-1\n                // Do both union and contains selectors because of case <div><div></div></div>\n                // or <div className=\"foo\"><div className=\"foo\"></div></div>\n\n                containsSelector = scopeClassName + ' ' + selectors[i];\n                scopedSelector.push(unionSelector, containsSelector);\n              } else {\n                containsSelector = scopeClassName + ' ' + selectors[i];\n                scopedSelector.push(containsSelector);\n              }\n            }\n\n            return scopedSelector.join(', ');\n          };\n\n          _this.getScopeClassName = function (styleString, rootElement) {\n            var hash = styleString;\n\n            if (rootElement) {\n              _this.pepper = '';\n\n              _this.traverseObjectToGeneratePepper(rootElement);\n\n              hash += _this.pepper;\n            }\n\n            return (__DEV__ ? 'scope-' : 's') + (0, _reactLibAdler2.default)(hash);\n          };\n\n          _this.traverseObjectToGeneratePepper = function (obj) {\n            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Max depth is equal to max depth of JSON.stringify\n            // Max length of 10,000 is arbitrary\n\n            if (depth > 32 || _this.pepper.length > 10000) return;\n\n            for (var prop in obj) {\n              // Avoid internal props that are unreliable\n              var isPropReactInternal = /^[_$]|type|ref|^value$/.test(prop);\n\n              if (!!obj[prop] && _typeof(obj[prop]) === 'object' && !isPropReactInternal) {\n                _this.traverseObjectToGeneratePepper(obj[prop], depth + 1);\n              } else if (!!obj[prop] && !isPropReactInternal && typeof obj[prop] !== 'function') {\n                _this.pepper += obj[prop];\n              }\n            }\n          };\n\n          _this.isVoidElement = function (type) {\n            return ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'].some(function (voidType) {\n              return type === voidType;\n            });\n          };\n\n          _this.addCSSTextToHead = function (cssText) {\n            if (!cssText.length) {\n              return;\n            } else {\n              var cssTextHash = (0, _reactLibAdler2.default)(cssText);\n\n              if (!window._reactiveStyle.cssTextHashesAddedToHead.some(function (hash) {\n                return hash === cssTextHash;\n              })) {\n                window._reactiveStyle.el.innerHTML += cssText;\n\n                window._reactiveStyle.cssTextHashesAddedToHead.push(cssTextHash);\n              }\n            }\n          };\n\n          _this.createStyleElement = function (cssText, scopeClassName) {\n            return _react2.default.createElement('style', {\n              type: 'text/css',\n              key: scopeClassName,\n              ref: function ref(c) {\n                return _this._style = c;\n              },\n              dangerouslySetInnerHTML: {\n                __html: cssText || ''\n              }\n            });\n          };\n\n          _this.getNewChildrenForCloneElement = function (cssText, rootElement, scopeClassName) {\n            return [_this.createStyleElement(cssText, scopeClassName)].concat(rootElement.props.children);\n          };\n\n          _this.scopeClassNameCache = {};\n          _this.scopedCSSTextCache = {};\n          return _this;\n        }\n\n        _createClass(Style, [{\n          key: 'render',\n          value: function render() {\n            if (!this.props.children) {\n              return this.createStyleElement();\n            }\n\n            var styleString = this.getStyleString();\n            var rootElement = this.getRootElement();\n\n            if (!styleString && rootElement) {\n              // Passthrough; no style actions\n              return rootElement.props.children;\n            } else if (styleString && !rootElement) {\n              // Global styling with no scoping\n              return this.createStyleElement(this.processCSSText(styleString), this.getScopeClassName(styleString, rootElement));\n            } else {\n              // Style tree of elements\n              var rootElementClassNames = rootElement.props.className ? rootElement.props.className + ' ' : '';\n              var rootElementId = rootElement.props.id ? rootElement.props.id : ''; // If styleString has already been calculated before and CSS text is unchanged;\n              // use the cached version. No need to recalculate.\n\n              var scopeClassName = void 0;\n              var scopedCSSText = void 0; // Include rootElementClassName and rootElementId as part of cache address\n              // to ensure upon state/prop change resulting in new id/class on root element\n              // will properly generate a union selector.\n              // WARNING: May be a preoptimization; cost of adding union selector to all selectors\n              // could be so low that its worth doing so to avoid surface space for bugs\n\n              var scopeClassNameAddress = rootElementClassNames + rootElementId + styleString;\n\n              if (this.scopeClassNameCache[scopeClassNameAddress]) {\n                // Use cached scope and scoped CSS Text\n                scopeClassName = this.scopeClassNameCache[scopeClassNameAddress];\n                scopedCSSText = this.scopedCSSTextCache[scopeClassName];\n              } else {\n                // Calculate scope and scoped CSS Text\n                scopeClassName = this.getScopeClassName(styleString, rootElement);\n                scopedCSSText = this.processCSSText(styleString, '.' + scopeClassName, this.getRootSelectors(rootElement)); // Cache for future use\n\n                this.scopeClassNameCache[scopeClassNameAddress] = scopeClassName;\n                this.scopedCSSTextCache[scopeClassName] = scopedCSSText;\n              }\n\n              return (0, _react.cloneElement)(rootElement, _extends({}, rootElement.props, {\n                className: '' + rootElementClassNames + scopeClassName\n              }), this.getNewChildrenForCloneElement(scopedCSSText, rootElement, scopeClassName));\n            }\n          }\n          /**\n           * Filters out the style string from this.props.children\n           *\n           *    > getStyleString()\n           *    \".foo { color: red; }\"\n           *\n           * @return {?string} string Style string\n           */\n\n          /**\n          * Filters out the root element from this.props.children\n          *\n          *    > getRootElement()\n          *    \"<MyRootElement />\"\n          *\n          * @return {?ReactDOMComponent} component Root element component\n          */\n\n          /**\n          * Creates an array of selectors which target the root element\n          *\n          *    > getRootSelectors( <div id=\"foo\" className=\"bar\" /> )\n          *    \"['#foo', '.bar']\"\n          *\n          * @param {ReactDOMComponent} component\n          * @return {!array} array Array of selectors that target the root element\n          */\n\n          /**\n          * Scopes CSS statement with a given scoping class name as a union or contains selector;\n          * also escapes CSS declaration bodies\n          *\n          *    > proccessStyleString( '.foo { color: red; } .bar { color: green; }', '_scoped-1234, ['.root', '.foo']  )\n          *    \".scoped-1234.foo { color: red; } .scoped-1234 .bar { color: green; }\"\n          *\n          * @param {string} styleString String of style rules\n          * @param {string} scopeClassName Class name used to create a unique scope\n          * @param {array} rootSelectors Array of selectors on the root element; ids and classNames\n          * @return {!string} Scoped style rule string\n          */\n\n          /**\n           * Escaper used in escapeTextContentForBrowser\n           *\n           */\n\n          /**\n           * Escapes text to prevent scripting attacks.\n           *\n           * @param {*} text Text value to escape.\n           * @return {string} An escaped string.\n           */\n\n          /**\n           * Scopes a selector with a given scoping className as a union or contains selector\n           *\n           *    > scopeSelector( '_scoped-1827481', '.root', ['.root', '.foo']  )\n           *    \".scoped-1827481.root\"\n           *\n           * @param {string} scopeClassName Class name used to scope selectors\n           * @param {string} selector Selector to scope\n           * @param {array} rootSelectors Array of selectors on the root element; ids and classNames\n           * @return {!string} Union or contains selector scoped with the scoping className\n           */\n\n          /**\n           * Creates a className used as a CSS scope by generating a checksum from a styleString\n           *\n           *    > scoped( 'footer { color: red; }' )\n           *    \"_scoped-182938591\"\n           *\n           * @param {string} String of style rules\n           * @return {!string} A scoping class name\n           */\n\n          /**\n           * Traverses an object tree looking for anything that is not internal or a circular\n           * reference. Accumulates values on this.pepper\n           *\n           *    > traverseObjectToGeneratePepper(obj)\n           *    void\n           * @param {object} object Object to traverse\n           */\n\n          /**\n           * Checks if a tag type is a self-closing void element\n           *\n           *    > isVoidElement( \"img\" )\n           *    \"true\"\n           *\n           * @param {*} string Element type to check\n           * @return {!bool} bool True or false\n           */\n\n          /**\n           * Add CSS text to the style element in the head of document unless it has\n           * already been added.\n           *\n           *    > addCSSTextToHead( \".foo { color: red; }\" )\n           *\n           * @param {string} string CSS text to add to head\n           */\n\n          /**\n          * Creates the style element used for server side rendering\n          *    > createStyleElement( \".foo._scoped-1 { color: red; }\" )\n          *\n          *\n          * @param {string} string CSS string\n          * @return {ReactDOMComponent} component\n          */\n\n          /**\n          * Returns new children for a root element being cloned. If mounted the CSS text\n          * is added to the style element in head, otherwise we are doing server side rendering\n          * and to avoid flash of unstyled content (FOUC) a style element is added to children\n          * to avoid FOUC on first render.\n          *\n          *    > getNewChildrenForCloneElement( \".foo._scoped-1 { color: red; }\" )\n          *     \"<NewChildren />\"\n          *\n          * @param {string} string CSS string\n          * @return {ReactDOMComponent} component\n          */\n\n          /**\n          * Syntactic sugar for functional usage of Reactive Style\n          *\n          *    > Style.it( \".foo { color: red; }\", <div /> )\n          *     \"<div class=\"_scoped-1\">\n          *        <style type=\"text/css\">\n          *          .foo._scoped-1 { color: red; }\n          *        </style>\n          *      </div>\"\n          *\n          * @param {string} string CSS string\n          * @param {ReactDOMComponent} component\n          */\n\n        }]);\n\n        return Style;\n      }(_react.Component);\n\n      Style.it = function (cssText, rootElement) {\n        return _react2.default.createElement(Style, null, cssText, rootElement);\n      };\n\n      exports.default = Style;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Copyright 2013-present, Facebook, Inc.\n       * All rights reserved.\n       *\n       * This source code is licensed under the BSD-style license found in the\n       * LICENSE file in the root directory of this source tree. An additional grant\n       * of patent rights can be found in the PATENTS file in the same directory.\n       *\n       * @providesModule adler32\n       */\n      'use strict';\n\n      var MOD = 65521; // adler32 is not cryptographically strong, and is only used to sanity check that\n      // markup generated on the server matches the markup generated on the client.\n      // This implementation (a modified version of the SheetJS version) has been optimized\n      // for our use case, at the expense of conforming to the adler32 specification\n      // for non-ascii inputs.\n\n      function adler32(data) {\n        var a = 1;\n        var b = 0;\n        var i = 0;\n        var l = data.length;\n        var m = l & ~0x3;\n\n        while (i < m) {\n          var n = Math.min(i + 4096, m);\n\n          for (; i < n; i += 4) {\n            b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));\n          }\n\n          a %= MOD;\n          b %= MOD;\n        }\n\n        for (; i < l; i++) {\n          b += a += data.charCodeAt(i);\n        }\n\n        a %= MOD;\n        b %= MOD;\n        return a | b << 16;\n      }\n\n      module.exports = adler32;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n      /***/\n    }\n    /******/\n    ])\n  );\n});\n\n;","map":null,"metadata":{},"sourceType":"script"}